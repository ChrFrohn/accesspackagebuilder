<#
.SYNOPSIS
    This script creates access packages in Microsoft Entra ID Entitle Management based on a JSON configuration file generated by the Access Package Builder tool. - https://accesspackagebuilder.azurewebsites.net/

.DESCRIPTION
    The script reads a JSON file containing access package definitions and processes them to create catalogs, access packages, and policies in Microsoft Entra ID Entitle management. It supports creating default, company, and department access packages, and adds specified Entra groups to these packages.
    The JSON file needs to be downloaded from https://accesspackagebuilder.azurewebsites.net/ and should contain the following structure:
    {
        "defaultAccessPackage": {
            "Default": [
                "Group 1",
                "Group 2"
            ]
        },
        "companyAccessPackages": {
            "CompanyName": [
                "Group 3"
            ]
        },
        "departmentAccessPackages": {
            "DepartmentName1": [
                "Group 4",
                "Group 5"
            ],
            "DepartmentName2": [
                "Group 6"
            ]
        }
    }

.PARAMETER JsonFilePath
    The path to the JSON file containing access package definitions.

.PARAMETER TenantId
    The Tenant ID of the Microsoft Entra ID.

.FUNCTIONS
    New-Catalog
        Creates a new catalog in Microsoft Entra ID.

    New-AccessPackage
        Creates a new access package in a specified catalog.

    New-AccessPackagePolicy
        Adds an initial policy to an access package.

    New-AccessPackageAutoAssignmentPolicy
        Adds an auto-assignment policy to an access package.

    Add-EntraGroupToAccessPackage
        Adds an Entra group to a specified catalog and access package.

    Get-OrCreateCatalog
        Retrieves an existing catalog or creates a new one if it doesn't exist.

    Invoke-AccessPackages
        Processes access packages based on the provided JSON configuration.

.NOTES
    Author: Christian Frohn
    Blog: https://www.christianfrohn.com
    Contact: https://www.linkedin.com/in/frohn/
    Date: 13-02-2025
    Version: 1.0

.LINK
    https://accesspackagebuilder.azurewebsites.net/
    https://github.com/ChrFrohn/Access-Package-Builder

.EXAMPLE
    .\CreateAccessPackageFromJSON.ps1
    Prompts the user for the JSON file path and Tenant ID, then processes the access packages defined in the JSON file.

#>

# Load JSON file from user input
$JsonFilePath = Read-Host "Enter the path to the JSON file"
if (-Not (Test-Path -Path $JsonFilePath)) {
    Write-Host "File not found" -ForegroundColor Red
    exit
}

$JSON = Get-Content -Path $JsonFilePath | ConvertFrom-Json

# Enter Tenant ID
$TenantId = Read-Host "Enter Tenant ID"

if ([string]::IsNullOrWhiteSpace($TenantId)) {
    Write-Host "Tenant ID cannot be empty" -ForegroundColor Red
    exit
}

# Function to create a catalog
function New-Catalog {
    param (
        [string]$CatalogDisplayName,
        [string]$CatalogDescription
    )

    try {
        New-MgEntitlementManagementCatalog -DisplayName $CatalogDisplayName -Description $CatalogDescription | out-null
        Write-Host "Catalog '$CatalogDisplayName' created successfully." -ForegroundColor Green
    } catch {
        Write-Host "Failed to create catalog '$CatalogDisplayName'. Error: $_" -ForegroundColor Red
    }
}

# Function to create access packages
function New-AccessPackage {
    param (
        [string]$DisplayName,
        [string]$Description,
        [string]$CatalogId
    )

    $AccessPackageParameters = @{
        displayName = $DisplayName
        description = $Description
        isHidden = $false
        catalog = @{
            id = $CatalogId
        }
    }
    
    try {
        New-MgEntitlementManagementAccessPackage -BodyParameter $AccessPackageParameters | out-null
        Write-Host "Access package '$DisplayName' created successfully." -ForegroundColor Green
    } catch {
        Write-Host "Failed to create access package '$DisplayName'. Error: $_" -ForegroundColor Red
    }
}

# Function to add Policy to Access Package
function New-AccessPackagePolicy {
    param (
        [string]$AccessPackageId
    )

    $params = @{
        displayName = "Initial Policy"
        description = "Initial Policy"
        allowedTargetScope = "notSpecified"
        specificAllowedTargets = @()
        expiration = @{
            endDateTime = $null
            duration = $null
            type = "noExpiration"
        }
        requestorSettings = @{
            enableTargetsToSelfAddAccess = $false
            enableTargetsToSelfUpdateAccess = $false
            enableTargetsToSelfRemoveAccess = $false
            allowCustomAssignmentSchedule = $true
            enableOnBehalfRequestorsToAddAccess = $false
            enableOnBehalfRequestorsToUpdateAccess = $false
            enableOnBehalfRequestorsToRemoveAccess = $false
            onBehalfRequestors = @()
        }
        requestApprovalSettings = @{
            isApprovalRequiredForAdd = $false
            isApprovalRequiredForUpdate = $false
            stages = @()
        }
        accessPackage = @{
            id = $AccessPackageId
        }
    }

    try {
        New-MgEntitlementManagementAssignmentPolicy -BodyParameter $params | out-null
        Write-Host "Access package policy created successfully for Access Package ID: $AccessPackageId." -ForegroundColor Green
    } catch {
        Write-Host "Failed to create access package policy for Access Package ID: $AccessPackageId. Error: $_" -ForegroundColor Red
    }
}

# Function to add Auto Assignment Policy to Access Package
function New-AccessPackageAutoAssignmentPolicy {
    param (
        [string]$PolicyName,
        [string]$PolicyDescription,
        [string]$AccessPackageId,
        [string]$AutoAssignmentPolicyFilter
    )

    $AutoPolicyParameters = @{
        displayName = $PolicyName
        description = $PolicyDescription
        allowedTargetScope = "specificDirectoryUsers"
        specificAllowedTargets = @(
            @{
                "@odata.type" = "#microsoft.graph.attributeRuleMembers"
                description = $PolicyDescription
                membershipRule = $AutoAssignmentPolicyFilter
            }
        )
        accessPackage = @{
            id = $AccessPackageId
        }
    }

    try {
        New-MgEntitlementManagementAssignmentPolicy -BodyParameter $AutoPolicyParameters | out-null
        Write-Host "Access package assignment policy: '$PolicyName' created successfully." -ForegroundColor Green
    } catch {
        Write-Host "Failed to create access package assignment policy '$PolicyName'. Error: $_" -ForegroundColor Red
    }
}

# Function to add Entra Group to Catalog
Function Add-EntraGroupToAccessPackage {
    param (
        [string]$CatalogId,
        [string]$GroupName,
        [string]$AccessPackageId
    )

    # Get the Group from Entra
    try {
        $EntraGroup = Get-MgGroup -Filter "DisplayName eq '$GroupName'"
    }
    catch {
        Write-Host "Error finding group '$GroupName': $_" -ForegroundColor Red
        return
    }

    if ($EntraGroup -eq $null) {
        Write-Host "Group '$GroupName' not found." -ForegroundColor Red
        return
    }

    $EntraGroup = $EntraGroup | Where-Object {
        ($_.ProxyAddresses.Count -eq 0) -or
        ($_.OnPremisesSyncEnabled -eq $false) -and
        ($_.GroupTypes -notcontains "DynamicMembership")
    }

    if ($EntraGroup) {
        Write-Host "Group found: $($EntraGroup.DisplayName)" -ForegroundColor Green
        $GroupObjectId = $EntraGroup.Id

        # Check if the group is already a resource in the catalog
        $CatalogResources = Get-MgEntitlementManagementCatalogResource -AccessPackageCatalogId $CatalogId -All
        $GroupResource = $CatalogResources | Where-Object { $_.OriginId -eq $GroupObjectId }

        if ($GroupResource) {
            Write-Host "The group with ID '$GroupObjectId' is already a resource in the catalog." -ForegroundColor Yellow
        } else {
            # Add the Group as a resource to the Catalog
            $GroupResourceAddParameters = @{
                requestType = "adminAdd"
                resource = @{
                    originId = $GroupObjectId
                    originSystem = "AadGroup"
                }
                catalog = @{
                    id = $CatalogId
                }
            }

            try {
                New-MgEntitlementManagementResourceRequest -BodyParameter $GroupResourceAddParameters | Out-Null
                Write-Host "Group with ID '$GroupObjectId' added to catalog successfully." -ForegroundColor Green
            } catch {
                Write-Host "Failed to add group with ID '$GroupObjectId' to catalog. Error: $_" -ForegroundColor Red
                return
            }
        }

        # Get the Group as a resource from the Catalog
        $CatalogResources = Get-MgEntitlementManagementCatalogResource -AccessPackageCatalogId $CatalogId -ExpandProperty "scopes" -All
        $GroupResource = $CatalogResources | Where-Object { $_.OriginId -eq $GroupObjectId }
        $GroupResourceScope = $GroupResource.Scopes[0]

        # Add the Group as a resource role to the Access Package
        $GroupResourceFilter = "(originSystem eq 'AadGroup' and resource/id eq '$($GroupResource.Id)')"
        $GroupResourceRoles = Get-MgEntitlementManagementCatalogResourceRole -AccessPackageCatalogId $CatalogId -Filter $GroupResourceFilter -ExpandProperty "resource"
        $GroupMemberRole = $GroupResourceRoles | Where-Object { $_.DisplayName -eq "Member" }

        $GroupResourceRoleScopeParameters = @{
            role = @{
                displayName = "Member"
                description = ""
                originSystem = $GroupMemberRole.OriginSystem
                originId = $GroupMemberRole.OriginId
                resource = @{
                    id = $GroupResource.Id
                    originId = $GroupResource.OriginId
                    originSystem = $GroupResource.OriginSystem
                }
            }
            scope = @{
                id = $GroupResourceScope.Id
                originId = $GroupResourceScope.OriginId
                originSystem = $GroupResourceScope.OriginSystem
            }
        }

        try {
            New-MgEntitlementManagementAccessPackageResourceRoleScope -AccessPackageId $AccessPackageId -BodyParameter $GroupResourceRoleScopeParameters | Out-Null
            Write-Host "Group '$GroupName' added to access package successfully." -ForegroundColor Green
        } catch {
            Write-Host "Failed to add group '$GroupName' to access package. Error: $_" -ForegroundColor Red
        }
    } else {
        Write-Host "Group '$GroupName' does not meet criteria." -ForegroundColor Yellow
    }
}

# Function to Create or Get catalog
function Get-OrCreateCatalog {
    param (
        [string]$CatalogDisplayName,
        [string]$CatalogDescription
    )

    $Catalogs = Get-MgEntitlementManagementCatalog -All
    $Catalog = $Catalogs | Where-Object DisplayName -eq $CatalogDisplayName
    if ($Catalog) {
        Write-Host "Catalog '$CatalogDisplayName' already exists." -ForegroundColor Yellow
    } else {
        try {
            New-Catalog -CatalogDisplayName $CatalogDisplayName -CatalogDescription $CatalogDescription
            $Catalog = Get-MgEntitlementManagementCatalog -Filter "displayName eq '$CatalogDisplayName'"
        } catch {
            Write-Host "Failed to create catalog '$CatalogDisplayName'. Error: $_" -ForegroundColor Red
            return $null
        }
    }
    return $Catalog
}

# Function to process access packages
function Invoke-AccessPackages {
    param (
        [string]$PackageType,
        [object]$Packages,
        [string]$CatalogDescription
    )

    Write-Host "Processing $PackageType access packages..." -ForegroundColor Magenta
    $Catalog = Get-OrCreateCatalog -CatalogDisplayName $PackageType -CatalogDescription $CatalogDescription
    if ($null -eq $Catalog) {
        return
    }

    foreach ($Package in $Packages.PSObject.Properties) {
        Write-Host "Processing access package: $($Package.Name)" -ForegroundColor Magenta
        # Check if the access package already exists
        $ExistingAccessPackage = Get-MgEntitlementManagementAccessPackage -Filter "displayName eq '$($Package.Name)'"
        if ($ExistingAccessPackage) {
            Write-Host "Access package '$($Package.Name)' already exists." -ForegroundColor Yellow
            $GetTheNewAccessPackage = $ExistingAccessPackage
        } else {
            try {
                New-AccessPackage -DisplayName $Package.Name -Description "$PackageType access package: $($Package.Name)" -CatalogId $Catalog.id
                $GetTheNewAccessPackage = Get-MgEntitlementManagementAccessPackage -Filter "displayName eq '$($Package.Name)'"

                # Create the "Initial Policy" for the access package
                New-AccessPackagePolicy -AccessPackageId $GetTheNewAccessPackage.Id

                # Create access package auto assignment policy for the access package
                $AutoAssignmentPolicyFilter = "(user.$PackageType -eq `"$($Package.Name)`")"
                New-AccessPackageAutoAssignmentPolicy -PolicyName "Policy for $($Package.Name)" -PolicyDescription "Policy for $($Package.Name)" -AccessPackageId $GetTheNewAccessPackage.Id -AutoAssignmentPolicyFilter $AutoAssignmentPolicyFilter
            } catch {
                Write-Host "Failed to create access package '$($Package.Name)'. Error: $_" -ForegroundColor Red
                continue
            }
        }

        # Add the groups to the access package
        foreach ($EntraGroup in $Package.Value) {
            Write-Host "Adding group '$EntraGroup' to catalog and access package..." -ForegroundColor Magenta
            Add-EntraGroupToAccessPackage -CatalogId $Catalog.Id -GroupName $EntraGroup -AccessPackageId $GetTheNewAccessPackage.Id
        }
    }
    Write-Host "Finished processing $PackageType access packages." -ForegroundColor Green
}

# Function to display access packages
function Show-AccessPackages {
    param (
        [string]$PackageType,
        [object]$Packages
    )

    foreach ($Package in $Packages.PSObject.Properties) {
        Write-Host "$PackageType access package: $($Package.Name)" -ForegroundColor Cyan
        Write-Host "Groups: $($Package.Value | Out-String)" -ForegroundColor Yellow
    }
}

Write-Host "Displaying access packages to be created..." -ForegroundColor Magenta
Show-AccessPackages -PackageType "Default" -Packages $JSON.defaultAccessPackage
Show-AccessPackages -PackageType "Company" -Packages $JSON.companyAccessPackages
Show-AccessPackages -PackageType "Department" -Packages $JSON.departmentAccessPackages

# Pause and wait for user to accept to proceed
$Continue = Read-Host "Do you want to proceed? (Y/N)"
if ($Continue -ne "Y") {
    Write-Host "Exiting script." -ForegroundColor Red
    exit
}

# Import module and connect to Microsoft Graph once
Connect-MgGraph -Scopes "EntitlementManagement.ReadWrite.All", "Group.Read.All" -TenantId $TenantId

# Process all access packages
Invoke-AccessPackages -PackageType "Default" -Packages $JSON.defaultAccessPackage -CatalogDescription "Default catalog"
Invoke-AccessPackages -PackageType "Company" -Packages $JSON.companyAccessPackages -CatalogDescription "Company catalog"
Invoke-AccessPackages -PackageType "Department" -Packages $JSON.departmentAccessPackages -CatalogDescription "Department catalog"